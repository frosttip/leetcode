# 98. Validate Binary Search Tree

ğŸŸ  Medium

Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

* The left subtree of a node contains only nodes with keys strictly less than the node's key.
* The right subtree of a node contains only nodes with keys strictly greater than the node's key.
* Both the left and right subtrees must also be binary search trees.

Example 1:

![alt text](image.png)
```
Input: root = [2,1,3]
Output: true
```

Example 2:

![alt text](image-1.png)
```
Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
```

Constraints:
- The number of nodes in the tree is in the range [1, 104].
- -231 <= Node.val <= 231 - 1

## Approach
### Recursiv
- **Parsing**: 
    é¡Œç›®çµ¦è¼¸å…¥ä¸€å€‹äºŒå…ƒæ¨¹ï¼Œè¦æ±‚ç¢ºèªé€™æ£µæ¨¹æ˜¯å¦æœ‰ç¬¦åˆBSTï¼Œ
    BSTè¦æ±‚å·¦å­æ¨¹çš„æ‰€æœ‰ç¯€é»å¿…é ˆå°æ–¼å…¶ä¹‹ä¸Šçš„ç¯€é»ã€‚
    BSTè¦æ±‚å³å­æ¨¹çš„æ‰€æœ‰ç¯€é»å¿…é ˆå¤§æ–¼å…¶ä¹‹ä¸Šçš„æ‰€æœ‰ç¯€é»ã€‚
    ä¸¦ä¸”å…©å€‹å­æ¨¹éƒ½å¿…é ˆç¬¦åˆä»¥ä¸Šè¦æ±‚ã€‚

    é€™é¡Œå¦‚æœä¸€é–‹å§‹çœ‹æœƒè¦ºå¾—åªè¦æ¯å€‹ç¯€é»éƒ½æ¯”è¼ƒå…¶å­æ¨¹çš„å…§å®¹ï¼Œå³é‚Šå¤§ï¼Œå·¦é‚Šå°å°±å¯ä»¥äº†ï¼Œå¯æ˜¯æ·±å…¥å»æ€è€ƒï¼Œ
    å°±æœƒç™¼è¦ºæœ‰é™·é˜±ï¼Œä¸åªæ˜¯ç•¶å‰ç¯€é»çš„ä¸‹ä¸€å€‹å±¤ç¯€é»è¦ç¬¦åˆæ¢ä»¶ï¼Œæ˜¯ä»¥ä¸‹çš„æ¯ä¸€å±¤éƒ½å¿…é ˆç¬¦åˆæ¢ä»¶ï¼Œ
    é€™å°±è¤‡é›œäº†ï¼Œæ‰€ä»¥å¿…é ˆæƒ³æ¸…æ¥šï¼Œåªé é¡Œç›®çš„è¼¸å…¥åƒæ•¸ä¸èƒ½å®Œæˆé‹ç®—ï¼Œæ‰€ä»¥è¦å»ºç«‹å¦ä¸€å€‹functionï¼Œ
    å¾æ ¹çµé»é–‹å§‹ï¼Œå³ç¯€é»çš„å…§å®¹éƒ½å¿…é ˆå¤§æ–¼ä»–ï¼Œæ‰€ä»¥å³å´çš„æ‰€æœ‰å…§å®¹éƒ½å¿…é ˆä»¥æ ¹çµé»ç•¶ä½œæœ€å°å€¼ï¼Œç„¶å¾Œå³å­æ¨¹ä¸­çš„å·¦å´å­«å­æ¨¹ï¼Œ
    å…¶å…§å®¹å°±å¿…é ˆè‡³å°‘å¤§æ–¼æ ¹çµé»ï¼Œç„¶å¾Œåˆè¦å°æ–¼å³å­æ¨¹ç¯€é»çš„å€¼ï¼Œé€™æ¨£å°±æœƒå‡ºç¾æœ€å¤§å€¼è·Ÿæœ€å°å€¼äº†ï¼Œæ‰€ä»¥æ¯ä¸‹ä¸€å±¤ï¼Œ
    å³å­æ¨¹å°±å¯ä»¥ä¸æ–·åœ°è®Šæ›æœ€å¤§å€¼èˆ‡æœ€å°å€¼ï¼Œåªè¦ä¸ç¬¦åˆå°±å¯ä»¥å›å‚³falseï¼Œç„¶å¾Œå°‡å…©å´çµæœANDèµ·ä¾†ï¼Œå› ç‚ºåªè¦ä¸€å´ä¸ç¬¦åˆæ¢ä»¶ï¼Œ
    é‚£æ•´æ£µæ¨¹å°±ä¸ç¬¦åˆï¼Œ
    å¦å¤–recursiveè¦æ€è€ƒæ€éº¼çµæŸï¼Œé€™è£¡åœæ­¢çš„æ¢ä»¶å°±åœ¨æ–¼ç•¶å‰ç¯€é»ç‚ºnullï¼Œåªè¦ç‚ºnullï¼Œé‚£å°±å¯ä»¥å›å‚³trueï¼Œå› ç‚ºæ²’æœ‰æ•¸å€¼å¯ä»¥åšåˆ¤æ–·ï¼Œ

    æ¥è‘—è§£æï¼Œ

    å»ºç«‹è£œåŠ©çš„functionï¼Œé€éå‰é¢è§£æï¼Œæˆ‘å€‘äº†è§£åˆ¤æ–·æœ‰æ²’æœ‰ç¬¦åˆéœ€è¦ä¸‰å€‹æ¢ä»¶ï¼Œ
    ç¬¬ä¸€ï¼Œè¦æœ‰æ¨¹ç¯€é»ï¼Œ
    ç¬¬äºŒï¼Œè¦æœ‰æœ€å°å€¼ï¼Œ
    ç¬¬ä¸‰ï¼Œè¦æœ‰æœ€å¤§å€¼ï¼Œ
    æ‰€ä»¥æ ¹æ“šé€™ä¸‰å€‹æ¢ä»¶å»ºç«‹è¼”åŠ©çš„functionï¼Œ
    ```
    bool help(TreeNode* root, long min, long max) {
    ```

    æ¥è‘—åœ¨éè¿´éç¨‹éœ€è¦æœ‰åœæ­¢çš„æ¢ä»¶ï¼Œç•¶é‡åˆ°ç©ºç¯€é»ï¼Œä»£è¡¨å·²ç¶“åˆ°åº•äº†ï¼Œ
    åˆ°åº•çš„æ™‚å€™ä¸éœ€è¦åˆ¤æ–·ï¼Œå› ç‚ºæ²’æœ‰æ±è¥¿ï¼Œç›´æ¥è¿”å›trueå³å¯ã€‚
    ```
    if(root==nullptr) {
        return true;
    }
    ```

    æ¥è‘—åˆ¤æ–·ç¯€é»æ˜¯å¦ç¬¦åˆBSTï¼Œé€™è£¡å¿…é ˆåˆ¤æ–·ç¯€é»å…§å®¹å°æ–¼manä¸¦ä¸”å¤§æ–¼minï¼Œåªè¦ä¸ç¬¦åˆå°±å›å‚³falseï¼Œ
    ```
    if(!(root->val < max && root->val > min)) {
        return false;
    }
    ```

    æ¥è‘—åˆ¤æ–·å·¦å­æ¨¹ï¼Œå› ç‚ºBSTè¦æ±‚å·¦å­æ¨¹éƒ½è¦å°æ–¼ç•¶å‰ç¯€é»ï¼Œæ‰€ä»¥æ›¿æ›maxç‚ºç•¶å‰ç¯€é»æ•¸å€¼ï¼Œminé‚„æ˜¯ç¶­æŒåŸç‹€ã€‚
    ```
    bool l = help(root->left, min, root->val);
    ```

    åˆ¤æ–·å³å­æ¨¹ï¼Œæ‰€æœ‰å³å­æ¨¹å…§å®¹éƒ½è¦å¤§æ–¼ç•¶å‰ç¯€é»ï¼Œæ‰€ä»¥æ›¿æ›minç‚ºç•¶å‰ç¯€é»æ•¸å€¼ï¼Œmaxç¶­æŒåŸç‹€ã€‚
    ```
    bool r = help(root->right, root->val, max);
    ```

    æœ€å¾Œå…©å€‹ç¯€é»åšANDï¼Œå› ç‚ºåªè¦å…¶ä¸­ä¸€å€‹çµæœç‚ºfalseï¼Œæ•´å€‹æ¨¹å°±ä¸ç¬¦åˆBSTã€‚
    ```
    return l&r;
    ```

    åœ¨æœ€å¾Œï¼Œåªè¦åœ¨é¡Œç›®æä¾›çš„functionï¼Œå‘¼å«ï¼Œä¸¦ä¸”å› ç‚ºæ˜¯ç¬¬ä¸€å±¤ï¼Œæ‰€ä»¥å¤§å°ä¸¦æ²’æœ‰é™åˆ¶ï¼Œæ‰€ä»¥minè·Ÿmaxéƒ½æ¡ç”¨longçš„æœ€å¤§è·Ÿæœ€å°å€¼å°±å¯ä»¥äº†ã€‚
    ```
    return help(root, LONG_MIN, LONG_MAX);
    ```
- **ç©ºé–“è¤‡é›œåº¦**: O(H) æ¨¹é«˜
- **æ™‚é–“è¤‡é›œåº¦**: O(N)